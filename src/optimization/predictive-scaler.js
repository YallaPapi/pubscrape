/**
 * Predictive Scaler - ML-Powered Automatic Scaling
 * Predicts future resource needs and scales the hive proactively
 */

class PredictiveScaler {
    constructor(config = {}) {
        this.config = {
            predictionHorizon: config.predictionHorizon || 4 * 60 * 60 * 1000, // 4 hours
            scaleUpThreshold: config.scaleUpThreshold || 0.8,
            scaleDownThreshold: config.scaleDownThreshold || 0.3,
            safetyBuffer: config.safetyBuffer || 0.2,
            minAgents: config.minAgents || 2,
            maxAgents: config.maxAgents || 20,
            scaleFactor: config.scaleFactor || 1.5,
            cooldownPeriod: config.cooldownPeriod || 5 * 60 * 1000, // 5 minutes
            ...config
        };
        
        // Core state
        this.status = 'initializing';
        this.currentAgentCount = 0;
        this.targetAgentCount = 0;
        this.lastScalingAction = 0;
        this.scalingInProgress = false;
        
        // Prediction models
        this.trendPredictor = new TrendPredictor(this.config.trendPredictor);
        this.workloadPredictor = new WorkloadPredictor(this.config.workloadPredictor);
        this.capacityPredictor = new CapacityPredictor(this.config.capacityPredictor);
        
        // Historical data
        this.performanceHistory = [];
        this.workloadHistory = [];
        this.scalingHistory = [];
        this.predictionHistory = [];
        
        // Callbacks
        this.scalingCallbacks = [];
        this.predictionCallbacks = [];\n    }\n    \n    async initialize() {\n        console.log('üìà Initializing Predictive Scaler...');\n        \n        try {\n            // Initialize prediction models\n            await Promise.all([\n                this.trendPredictor.initialize(),\n                this.workloadPredictor.initialize(),\n                this.capacityPredictor.initialize()\n            ]);\n            \n            // Start prediction loops\n            this.startPredictionLoops();\n            \n            this.status = 'active';\n            console.log('‚úÖ Predictive Scaler initialized successfully');\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize Predictive Scaler:', error);\n            this.status = 'failed';\n            throw error;\n        }\n    }\n    \n    startPredictionLoops() {\n        // Main prediction loop - every 2 minutes\n        this.predictionInterval = setInterval(() => {\n            this.generatePredictions();\n        }, 120000);\n        \n        // Scaling evaluation loop - every minute\n        this.scalingInterval = setInterval(() => {\n            this.evaluateScalingNeed();\n        }, 60000);\n        \n        // Model training loop - every 10 minutes\n        this.trainingInterval = setInterval(() => {\n            this.trainModels();\n        }, 600000);\n        \n        console.log('üîÑ Predictive scaling loops started');\n    }\n    \n    async generatePredictions() {\n        try {\n            const currentTime = Date.now();\n            const futureTime = currentTime + this.config.predictionHorizon;\n            \n            // Generate predictions from different models\n            const trendPrediction = await this.trendPredictor.predict(futureTime);\n            const workloadPrediction = await this.workloadPredictor.predict(futureTime);\n            const capacityPrediction = await this.capacityPredictor.predict(futureTime);\n            \n            // Combine predictions with confidence weighting\n            const combinedPrediction = this.combinePredictions([\n                { prediction: trendPrediction, weight: 0.3 },\n                { prediction: workloadPrediction, weight: 0.4 },\n                { prediction: capacityPrediction, weight: 0.3 }\n            ]);\n            \n            // Store prediction\n            this.predictionHistory.push({\n                timestamp: currentTime,\n                targetTime: futureTime,\n                individual: {\n                    trend: trendPrediction,\n                    workload: workloadPrediction,\n                    capacity: capacityPrediction\n                },\n                combined: combinedPrediction\n            });\n            \n            // Trim prediction history\n            if (this.predictionHistory.length > 100) {\n                this.predictionHistory = this.predictionHistory.slice(-100);\n            }\n            \n            // Notify callbacks\n            this.notifyPredictionCallbacks(combinedPrediction);\n            \n        } catch (error) {\n            console.error('‚ùå Error generating predictions:', error);\n        }\n    }\n    \n    combinePredictions(weightedPredictions) {\n        const totalWeight = weightedPredictions.reduce((sum, wp) => sum + wp.weight, 0);\n        \n        let combinedLoad = 0;\n        let combinedConfidence = 0;\n        let combinedAgentNeed = 0;\n        \n        for (const { prediction, weight } of weightedPredictions) {\n            const normalizedWeight = weight / totalWeight;\n            combinedLoad += prediction.expectedLoad * normalizedWeight;\n            combinedConfidence += prediction.confidence * normalizedWeight;\n            combinedAgentNeed += prediction.recommendedAgents * normalizedWeight;\n        }\n        \n        return {\n            expectedLoad: combinedLoad,\n            confidence: combinedConfidence,\n            recommendedAgents: Math.round(combinedAgentNeed),\n            timestamp: Date.now()\n        };\n    }\n    \n    async evaluateScalingNeed() {\n        if (this.scalingInProgress) {\n            return;\n        }\n        \n        try {\n            // Check cooldown period\n            if (Date.now() - this.lastScalingAction < this.config.cooldownPeriod) {\n                return;\n            }\n            \n            // Get latest prediction\n            const latestPrediction = this.getLatestPrediction();\n            if (!latestPrediction) {\n                return;\n            }\n            \n            // Current system state\n            const currentLoad = await this.getCurrentLoad();\n            const currentAgents = await this.getCurrentAgentCount();\n            \n            // Calculate scaling decision\n            const scalingDecision = this.calculateScalingDecision(\n                currentLoad,\n                currentAgents,\n                latestPrediction\n            );\n            \n            if (scalingDecision.action !== 'none') {\n                await this.executeScaling(scalingDecision);\n            }\n            \n        } catch (error) {\n            console.error('‚ùå Error evaluating scaling need:', error);\n        }\n    }\n    \n    calculateScalingDecision(currentLoad, currentAgents, prediction) {\n        const decision = {\n            action: 'none',\n            reason: '',\n            currentAgents,\n            targetAgents: currentAgents,\n            confidence: prediction.confidence\n        };\n        \n        // Predicted load with safety buffer\n        const bufferedLoad = prediction.expectedLoad * (1 + this.config.safetyBuffer);\n        \n        // Scale up conditions\n        if (bufferedLoad > this.config.scaleUpThreshold) {\n            const targetAgents = Math.min(\n                this.config.maxAgents,\n                Math.ceil(prediction.recommendedAgents * this.config.scaleFactor)\n            );\n            \n            if (targetAgents > currentAgents) {\n                decision.action = 'scale_up';\n                decision.targetAgents = targetAgents;\n                decision.reason = `Predicted load ${(prediction.expectedLoad * 100).toFixed(1)}% exceeds threshold`;\n            }\n        }\n        // Scale down conditions\n        else if (prediction.expectedLoad < this.config.scaleDownThreshold) {\n            const targetAgents = Math.max(\n                this.config.minAgents,\n                Math.floor(prediction.recommendedAgents)\n            );\n            \n            if (targetAgents < currentAgents) {\n                decision.action = 'scale_down';\n                decision.targetAgents = targetAgents;\n                decision.reason = `Predicted load ${(prediction.expectedLoad * 100).toFixed(1)}% below threshold`;\n            }\n        }\n        \n        return decision;\n    }\n    \n    async executeScaling(scalingDecision) {\n        if (this.scalingInProgress) {\n            throw new Error('Scaling already in progress');\n        }\n        \n        this.scalingInProgress = true;\n        const startTime = Date.now();\n        \n        try {\n            console.log(`üìà Executing ${scalingDecision.action}: ${scalingDecision.currentAgents} ‚Üí ${scalingDecision.targetAgents}`);\n            \n            // Record scaling attempt\n            const scalingRecord = {\n                timestamp: startTime,\n                action: scalingDecision.action,\n                fromAgents: scalingDecision.currentAgents,\n                toAgents: scalingDecision.targetAgents,\n                reason: scalingDecision.reason,\n                confidence: scalingDecision.confidence,\n                status: 'in_progress'\n            };\n            \n            this.scalingHistory.push(scalingRecord);\n            \n            // Execute the scaling\n            const result = await this.performScaling(scalingDecision);\n            \n            // Update record\n            scalingRecord.status = result.success ? 'completed' : 'failed';\n            scalingRecord.duration = Date.now() - startTime;\n            scalingRecord.actualAgents = result.actualAgentCount;\n            scalingRecord.error = result.error;\n            \n            // Update state\n            this.lastScalingAction = Date.now();\n            this.currentAgentCount = result.actualAgentCount || scalingDecision.currentAgents;\n            this.targetAgentCount = scalingDecision.targetAgents;\n            \n            // Notify callbacks\n            this.notifyScalingCallbacks(scalingRecord);\n            \n            console.log(`‚úÖ Scaling ${result.success ? 'completed' : 'failed'}: ${scalingRecord.fromAgents} ‚Üí ${scalingRecord.actualAgents}`);\n            \n        } catch (error) {\n            console.error('‚ùå Scaling execution failed:', error);\n            throw error;\n        } finally {\n            this.scalingInProgress = false;\n        }\n    }\n    \n    async performScaling(scalingDecision) {\n        // This would integrate with the actual agent management system\n        // For now, simulating the scaling operation\n        \n        const { action, targetAgents, currentAgents } = scalingDecision;\n        \n        try {\n            if (action === 'scale_up') {\n                // Add agents\n                const agentsToAdd = targetAgents - currentAgents;\n                for (let i = 0; i < agentsToAdd; i++) {\n                    await this.spawnAgent();\n                    await this.delay(1000); // Gradual spawning\n                }\n            } else if (action === 'scale_down') {\n                // Remove agents\n                const agentsToRemove = currentAgents - targetAgents;\n                for (let i = 0; i < agentsToRemove; i++) {\n                    await this.terminateAgent();\n                    await this.delay(500); // Gradual termination\n                }\n            }\n            \n            return {\n                success: true,\n                actualAgentCount: targetAgents\n            };\n            \n        } catch (error) {\n            return {\n                success: false,\n                actualAgentCount: currentAgents,\n                error: error.message\n            };\n        }\n    }\n    \n    async emergencyScale(options) {\n        console.log('üö® Emergency scaling triggered:', options);\n        \n        const emergencyDecision = {\n            action: 'scale_up',\n            currentAgents: await this.getCurrentAgentCount(),\n            targetAgents: options.targetAgents,\n            reason: `Emergency scaling: ${options.reason}`\n        };\n        \n        // Override cooldown for emergency scaling\n        this.lastScalingAction = 0;\n        \n        await this.executeScaling(emergencyDecision);\n    }\n    \n    async trainModels() {\n        try {\n            console.log('üß† Training predictive models...');\n            \n            // Prepare training data\n            const trainingData = this.prepareTrainingData();\n            \n            if (trainingData.length < 10) {\n                console.log('üìä Insufficient data for model training');\n                return;\n            }\n            \n            // Train each model\n            await Promise.all([\n                this.trendPredictor.train(trainingData),\n                this.workloadPredictor.train(trainingData),\n                this.capacityPredictor.train(trainingData)\n            ]);\n            \n            // Evaluate model performance\n            const modelPerformance = await this.evaluateModelPerformance();\n            console.log('üìà Model training completed. Performance:', modelPerformance);\n            \n        } catch (error) {\n            console.error('‚ùå Error training models:', error);\n        }\n    }\n    \n    prepareTrainingData() {\n        // Combine performance and workload history\n        const combinedData = [];\n        \n        for (const perf of this.performanceHistory) {\n            const workload = this.workloadHistory.find(w => \n                Math.abs(w.timestamp - perf.timestamp) < 30000 // Within 30 seconds\n            );\n            \n            if (workload) {\n                combinedData.push({\n                    timestamp: perf.timestamp,\n                    features: {\n                        cpuUsage: perf.system.cpuUsage,\n                        memoryUsage: perf.system.memoryUsage,\n                        taskCount: perf.hive.totalTasks,\n                        throughput: perf.hive.throughput,\n                        errorRate: perf.hive.errorRate,\n                        agentCount: perf.coordination.agentCount,\n                        workloadComplexity: workload.complexity,\n                        workloadParallelism: workload.parallelizability\n                    },\n                    target: {\n                        load: perf.composite,\n                        optimalAgents: this.calculateOptimalAgents(perf)\n                    }\n                });\n            }\n        }\n        \n        return combinedData;\n    }\n    \n    calculateOptimalAgents(performanceData) {\n        // Calculate what the optimal agent count should have been\n        const load = performanceData.composite;\n        const currentAgents = performanceData.coordination.agentCount;\n        \n        if (load > 0.8) {\n            return Math.min(this.config.maxAgents, currentAgents * 1.5);\n        } else if (load < 0.3) {\n            return Math.max(this.config.minAgents, currentAgents * 0.7);\n        }\n        \n        return currentAgents;\n    }\n    \n    async evaluateModelPerformance() {\n        // Evaluate how accurate our predictions have been\n        const recentPredictions = this.predictionHistory.slice(-20);\n        const performance = {\n            accuracy: 0,\n            meanAbsoluteError: 0,\n            confidenceCorrelation: 0\n        };\n        \n        if (recentPredictions.length === 0) {\n            return performance;\n        }\n        \n        let totalError = 0;\n        let accurateCount = 0;\n        \n        for (const prediction of recentPredictions) {\n            // Find actual performance at the predicted time\n            const actualPerf = this.performanceHistory.find(p => \n                Math.abs(p.timestamp - prediction.targetTime) < 60000 // Within 1 minute\n            );\n            \n            if (actualPerf) {\n                const predictedLoad = prediction.combined.expectedLoad;\n                const actualLoad = actualPerf.composite;\n                const error = Math.abs(predictedLoad - actualLoad);\n                \n                totalError += error;\n                if (error < 0.1) accurateCount++; // Within 10%\n            }\n        }\n        \n        performance.accuracy = accurateCount / recentPredictions.length;\n        performance.meanAbsoluteError = totalError / recentPredictions.length;\n        \n        return performance;\n    }\n    \n    // Event handlers\n    onScalingPrediction(callback) {\n        this.predictionCallbacks.push(callback);\n    }\n    \n    onScalingAction(callback) {\n        this.scalingCallbacks.push(callback);\n    }\n    \n    // Notification methods\n    notifyPredictionCallbacks(prediction) {\n        this.predictionCallbacks.forEach(callback => {\n            try {\n                callback(prediction);\n            } catch (error) {\n                console.error('‚ùå Error in prediction callback:', error);\n            }\n        });\n    }\n    \n    notifyScalingCallbacks(scalingRecord) {\n        this.scalingCallbacks.forEach(callback => {\n            try {\n                callback(scalingRecord);\n            } catch (error) {\n                console.error('‚ùå Error in scaling callback:', error);\n            }\n        });\n    }\n    \n    // Data update methods\n    updatePerformanceData(performanceData) {\n        this.performanceHistory.push(performanceData);\n        \n        // Trim history\n        if (this.performanceHistory.length > 1000) {\n            this.performanceHistory = this.performanceHistory.slice(-1000);\n        }\n    }\n    \n    updateWorkloadData(workloadData) {\n        this.workloadHistory.push(workloadData);\n        \n        // Trim history\n        if (this.workloadHistory.length > 1000) {\n            this.workloadHistory = this.workloadHistory.slice(-1000);\n        }\n    }\n    \n    // Public API\n    getPredictions() {\n        return {\n            latest: this.getLatestPrediction(),\n            history: this.predictionHistory.slice(-10),\n            confidence: this.getAverageConfidence()\n        };\n    }\n    \n    getLatestPrediction() {\n        return this.predictionHistory.length > 0 \n            ? this.predictionHistory[this.predictionHistory.length - 1].combined\n            : null;\n    }\n    \n    getAverageConfidence() {\n        if (this.predictionHistory.length === 0) return 0;\n        \n        const recentPredictions = this.predictionHistory.slice(-5);\n        return recentPredictions.reduce((sum, p) => sum + p.combined.confidence, 0) / recentPredictions.length;\n    }\n    \n    getScalingHistory() {\n        return this.scalingHistory.slice(-20);\n    }\n    \n    getStatus() {\n        return {\n            status: this.status,\n            currentAgents: this.currentAgentCount,\n            targetAgents: this.targetAgentCount,\n            scalingInProgress: this.scalingInProgress,\n            lastScaling: this.lastScalingAction,\n            cooldownRemaining: Math.max(0, this.config.cooldownPeriod - (Date.now() - this.lastScalingAction))\n        };\n    }\n    \n    // Utility methods\n    async delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    async getCurrentLoad() {\n        // Mock current load calculation\n        return Math.random() * 0.8 + 0.1;\n    }\n    \n    async getCurrentAgentCount() {\n        // Mock current agent count\n        return this.currentAgentCount || Math.floor(Math.random() * 8) + 3;\n    }\n    \n    async spawnAgent() {\n        // Mock agent spawning\n        console.log('‚ûï Spawning new agent');\n        await this.delay(2000);\n        return true;\n    }\n    \n    async terminateAgent() {\n        // Mock agent termination\n        console.log('‚ûñ Terminating agent');\n        await this.delay(1000);\n        return true;\n    }\n    \n    stop() {\n        console.log('üõë Stopping Predictive Scaler...');\n        \n        // Clear intervals\n        if (this.predictionInterval) clearInterval(this.predictionInterval);\n        if (this.scalingInterval) clearInterval(this.scalingInterval);\n        if (this.trainingInterval) clearInterval(this.trainingInterval);\n        \n        // Stop prediction models\n        this.trendPredictor.stop();\n        this.workloadPredictor.stop();\n        this.capacityPredictor.stop();\n        \n        this.status = 'stopped';\n        console.log('‚úÖ Predictive Scaler stopped');\n    }\n}\n\n// Mock prediction models for demonstration\nclass TrendPredictor {\n    constructor(config) {\n        this.config = config || {};\n        this.windowSize = this.config.windowSize || 50;\n        this.model = null;\n    }\n    \n    async initialize() {\n        console.log('üìä TrendPredictor initialized');\n        this.model = { trained: false };\n    }\n    \n    async predict(targetTime) {\n        // Mock trend-based prediction\n        const baseLoad = 0.5 + Math.sin(Date.now() / 1000000) * 0.3;\n        const noise = (Math.random() - 0.5) * 0.1;\n        \n        return {\n            expectedLoad: Math.max(0, Math.min(1, baseLoad + noise)),\n            confidence: 0.7 + Math.random() * 0.2,\n            recommendedAgents: Math.ceil((baseLoad + noise) * 10) + 2\n        };\n    }\n    \n    async train(trainingData) {\n        console.log(`üìà Training TrendPredictor with ${trainingData.length} samples`);\n        // Mock training\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        this.model.trained = true;\n    }\n    \n    stop() {\n        console.log('üìä TrendPredictor stopped');\n    }\n}\n\nclass WorkloadPredictor {\n    constructor(config) {\n        this.config = config || {};\n        this.model = null;\n    }\n    \n    async initialize() {\n        console.log('üîÑ WorkloadPredictor initialized');\n        this.model = { trained: false };\n    }\n    \n    async predict(targetTime) {\n        // Mock workload-based prediction\n        const hourOfDay = new Date(targetTime).getHours();\n        const workloadFactor = hourOfDay >= 9 && hourOfDay <= 17 ? 1.2 : 0.8; // Higher during work hours\n        const baseLoad = 0.4 * workloadFactor;\n        \n        return {\n            expectedLoad: Math.max(0, Math.min(1, baseLoad + Math.random() * 0.2)),\n            confidence: 0.75 + Math.random() * 0.15,\n            recommendedAgents: Math.ceil(baseLoad * 12) + 1\n        };\n    }\n    \n    async train(trainingData) {\n        console.log(`üîÑ Training WorkloadPredictor with ${trainingData.length} samples`);\n        // Mock training\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        this.model.trained = true;\n    }\n    \n    stop() {\n        console.log('üîÑ WorkloadPredictor stopped');\n    }\n}\n\nclass CapacityPredictor {\n    constructor(config) {\n        this.config = config || {};\n        this.model = null;\n    }\n    \n    async initialize() {\n        console.log('‚öñÔ∏è CapacityPredictor initialized');\n        this.model = { trained: false };\n    }\n    \n    async predict(targetTime) {\n        // Mock capacity-based prediction\n        const resourceLoad = 0.6 + Math.random() * 0.3;\n        \n        return {\n            expectedLoad: resourceLoad,\n            confidence: 0.8 + Math.random() * 0.15,\n            recommendedAgents: Math.ceil(resourceLoad * 8) + 3\n        };\n    }\n    \n    async train(trainingData) {\n        console.log(`‚öñÔ∏è Training CapacityPredictor with ${trainingData.length} samples`);\n        // Mock training\n        await new Promise(resolve => setTimeout(resolve, 1200));\n        this.model.trained = true;\n    }\n    \n    stop() {\n        console.log('‚öñÔ∏è CapacityPredictor stopped');\n    }\n}\n\nmodule.exports = { PredictiveScaler };